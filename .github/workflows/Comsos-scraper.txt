- name: Normalize + dedupe (Mux low → high only)
  run: |
    node - <<'NODE'
    const fs = require('fs');
    const path = require('path');

    const PUB = path.resolve(process.cwd(), 'public');
    if (!fs.existsSync(PUB)) process.exit(0);

    const files = fs.readdirSync(PUB).filter(f => f.endsWith('.json'));

    const MUX_HOST = 'stream.mux.com';

    const normUrl = (url) => {
      try {
        const u = new URL(url);
        u.hash = '';
        u.search = '';
        u.host = u.host.toLowerCase();
        return u.toString();
      } catch {
        return null;
      }
    };

    const muxPlaybackId = (url) => {
      try {
        const u = new URL(url);
        if (u.host.toLowerCase() !== MUX_HOST) return null;
        const seg = u.pathname.split('/').filter(Boolean);
        return seg[0] || null;
      } catch {
        return null;
      }
    };

    const upgradeMux = (url) => {
      try {
        const u = new URL(url);
        if (u.host.toLowerCase() !== MUX_HOST) return url;
        const seg = u.pathname.split('/').filter(Boolean);
        if (seg.length < 2) return url;
        seg[1] = 'high.mp4';
        u.pathname = '/' + seg.join('/');
        u.search = '';
        u.hash = '';
        return u.toString();
      } catch {
        return url;
      }
    };

    const cosmosUuidFromPath = (url) => {
      try {
        const u = new URL(url);
        const m = u.pathname.match(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i);
        return m ? m[0].toLowerCase() : null;
      } catch {
        return null;
      }
    };

    const isVideo = (url) => {
      try {
        return /\.(mp4|webm|m4v|mov)$/i.test(new URL(url).pathname);
      } catch {
        return false;
      }
    };

    for (const file of files) {
      const full = path.join(PUB, file);

      let data;
      try { data = JSON.parse(fs.readFileSync(full, 'utf8')); }
      catch { continue; }

      const list = Array.isArray(data) ? data
        : Array.isArray(data.items) ? data.items
        : [];

      const out = [];
      const seen = new Set();

      for (const raw of list) {
        const item = { ...raw };

        let src = item.src || item.url || item.image || item.href;
        if (!src) continue;

        src = normUrl(src) || src;

        const pb = muxPlaybackId(src);
        if (pb) src = upgradeMux(src);

        const nsrc = normUrl(src);
        if (!nsrc) continue;

        if (item.poster) {
          const p = normUrl(item.poster);
          if (p) item.poster = p;
        }

        const type = (item.type || (isVideo(nsrc) ? 'video' : 'image')).toLowerCase();
        item.type = type;
        item.src = nsrc;

        // Dedupe key priority:
        // 1) stable key from scraper if present
        // 2) mux playback id for mux videos
        // 3) cosmos uuid in path when present
        // 4) final fallback: full url
        let key = null;

        if (item.key) key = `${type}:key:${String(item.key)}`;
        else if (type === 'video' && pb) key = `video:mux:${pb}`;
        else {
          const uuid = cosmosUuidFromPath(nsrc);
          if (uuid) key = `${type}:uuid:${uuid}`;
        }
        if (!key) key = `${type}:url:${nsrc}`;

        if (seen.has(key)) continue;
        seen.add(key);

        out.push(item);
      }

      const finalObj =
        Array.isArray(data) ? out :
        Array.isArray(data.items) ? { ...data, items: out, count: out.length } :
        out;

      fs.writeFileSync(full, JSON.stringify(finalObj, null, 2));
      console.log(`✔ ${file}: ${list.length} → ${out.length} (low→high, deduped)`);
    }
    NODE